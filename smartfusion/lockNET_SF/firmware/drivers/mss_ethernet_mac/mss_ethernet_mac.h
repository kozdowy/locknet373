/***************************************************************************//**
 * (c) Copyright 2012-2015 Microsemi SoC Products Group.  All rights reserved.
 *
 * SmartFusion Microcontroller Subsystem 10/100 Mbps Ethernet MAC bare metal
 * software driver public API.
 *
 *
 * SVN $Revision: 7582 $
 * SVN $Date: 2015-07-23 12:53:17 +0530 (Thu, 23 Jul 2015) $
 *
 *******************************************************************************/
/*=========================================================================*//**
  @mainpage SmartFusion MSS Ethernet MAC Bare Metal Driver.

  @section intro_sec Introduction
    The SmartFusion microcontroller subsystem (MSS) includes one 10/100
    Mbps Ethernet MAC hardware peripheral. The MSS Ethernet MAC supports 
    RMII interface to the physical layer devices (PHY).
    This software driver provides a set of functions for controlling
    the MSS Ethernet MAC as part of a bare metal system where no operating system
    is available. This driver can be adapted for use as part of an operating
    system but the implementation of the adaptation layer between this driver and
    the operating system's driver model is outside the scope of this driver.
    
  @section hw_dependencies Hardware Flow Dependencies
    The configuration of all features of the MSS Ethernet MAC is covered by this
    driver with the exception of the selection of the Ethernet PHY connected to
    the MAC and the size of the transmit and receive rings.
    The driver for the Ethernet PHY connected to the SmartFusion MSS Ethernet
    MAC is selected using the Firmware Catalog configuration dialog window. It
    gives the option of using one of a set of supported PHYs. This choice will
    affect which source file will be generated by the Firmware Catalog.
    The number of transmit and receive buffers is also selected using the
    Firmware Catalog. The Firmware Catalog generates a C header file containing
    these choices which is used as part of the MSS Ethernet MAC implementation.
    The selected values will be used to define the size of the transmit and
    receive descriptor rings within the driver. They define the maximum number
    of transmit and receive packets that can be queued.
    The base address, register addresses and interrupt number assignment for the
    MSS Ethernet MAC are defined as constants in the SmartFusion CMSIS HAL. You
    must ensure that the latest SmartFusion CMSIS HAL is included in the
    project settings of the software tool chain used to build your project and
    that it is generated into your project.

  @section theory_op Theory of Operation
    The MSS Ethernet MAC driver functions are grouped into the following
    categories:
    •    Initialization and configuration
    •    Transmit operations
    •    Receive operations
    •    Reading link status and statistics

    Initialization and Configuration
    The SmartFusion Ethernet MAC driver is initialized and configured by
    calling the MSS_MAC_init()function. The MSS_MAC_init() function takes a
    pointer to a configuration data structure as parameter. This data structure
    contains all the configuration information required to initialize and
    configure the Ethernet MAC. 
    The Ethernet MAC driver provides the MSS_MAC_cfg_struct_def_init() function
    to initialize the configuration data structure to default value. It is
    recommended to use this function to retrieve the default configuration than
    overwrite the defaults with the application specific settings such as 
    PHY address, allowed link speeds, link duplex mode and MAC address.
    
    The following functions are used as part of the initialization and
    configuration process:
        - MSS_MAC_cfg_struct_def_init()
        - MSS_MAC_init()

    Transmit Operations
    The SmartFusion Ethernet MAC driver transmit operations are interrupt
    driven. The application must register a transmit call-back function with the
    driver using the MSS_MAC_set_tx_callback() function. This call-back function
    will be called by the Ethernet MAC driver every time a packet has been sent.
    The application must call the MSS_MAC_send_pkt() function every time it
    wants to transmit a packet. The application must pass a pointer to the
    buffer containing the packet to send. It is the application’s responsibility
    to manage the memory allocated to store the transmit packets. The Ethernet
    MAC driver only requires a pointer to the buffer containing the packet and
    the packet size. The Ethernet MAC driver will call the transmit call-back
    function registered using the MSS_MAC_set_tx_callback() function once a
    packet is sent. The transmit call-back function is supplied by the
    application and can be used to release the memory used to store the packet
    that was sent.
    The following functions are used as part of transmit operations:
        - MSS_MAC_send_pkt()
        - MSS_MAC_set_tx_callback()

    Receive Operations
    The SmartFusion Ethernet MAC driver receive operations are interrupt
    driven. The application must first register a receive call-back function
    using the MSS_MAC_set_rx_callback() function. The application can then
    allocate receive buffers to the Ethernet MAC driver by calling the
    MSS_MAC_receive_pkt() function. This function can be called multiple times
    to allocate more than one receive buffer. The Ethernet MAC driver will then
    call the receive call-back whenever a packet is received into one of the
    receive buffer. It will hand back the receive buffer to the application for
    packet processing. This buffer will not be reused by the Ethernet MAC driver
    unless it is re-allocated to the driver by a call to MSS_MAC_receive_pkt().
    The following functions are used as part of receive operations:
        - MSS_MAC_receive_pkt()
        - MSS_MAC_set_rx_callback()

    Reading Status and Statistics
    The Ethernet MAC driver provides the following functions to retrieve the
    current link status and statistics.
        - MSS_MAC_get_link_status()
        - MSS_MAC_read_stat()
        - MSS_MAC_clear_statistics()

*//*=========================================================================*/
#ifndef MSS_ETHERNET_MAC_H_
#define MSS_ETHERNET_MAC_H_    1

#include "cpu_types.h"
#include "mss_ethernet_mac_user_config.h"

#ifdef __cplusplus
extern "C" {
#endif 

/******************************** DEFINES *************************************/

/*******************************************************************************
 Configuration parameters.
 The definitions listed below are provided to populate the configuration, of
 type mss_mac_cfg_t, provided as parameter to the MSS_MAC_init() function. The
 MSS_MAC_cfg_struct_def_init() function call initializes a configuration record
 with default values. This default configuration record can be customized using
 the definitions below prior to calling MSS_MAC_init().
*/

/*
 * Generic enable and disable.
 */
#define MSS_MAC_ENABLE      1u
#define MSS_MAC_DISABLE     0u

/*
 * Function return values.
 */
#define MSS_MAC_SUCCESS     ((uint8_t) 1u)
#define MSS_MAC_FAILED      ((uint8_t) 0u)

/*
 * Transmit threshold mode.
 * 1 - Transmit FIFO threshold set for 100 Mbps mode
 * 0 - Transmit FIFO threshold set for 10 Mbps mode
 * This configuration can be changed only when a transmit process is in a stopped
 * state.
 */
#define MSS_MAC_CFG_TX_THRESHOLD_100MB_MODE             (uint8_t)0x01
#define MSS_MAC_CFG_TX_THRESHOLD_10MB_MODE              (uint8_t)0x00

/*
 * Threshold control bits.
 * These bits, together with TTM, SF, and PS, control the threshold level for the
 * transmit FIFO.
 */
#define MSS_MAC_CFG_THRESHOLD_CONTROL_00                (uint8_t)0x00000000
#define MSS_MAC_CFG_THRESHOLD_CONTROL_01                (uint8_t)0x00000001
#define MSS_MAC_CFG_THRESHOLD_CONTROL_10                (uint8_t)0x00000002
#define MSS_MAC_CFG_THRESHOLD_CONTROL_11                (uint8_t)0x00000003

/********************************************************************************
  The following definitions are used to specify the allowed link speed and duplex
  mode as part of the driver configuration. These definitions are used to create
  a bitmask value for the linkspeed configuration parameter.
 */
#define MSS_MAC_ANEG_10M_FD         0x01u
#define MSS_MAC_ANEG_10M_HD         0x02u
#define MSS_MAC_ANEG_100M_FD        0x04u
#define MSS_MAC_ANEG_100M_HD        0x08u
#define MSS_MAC_ANEG_ALL_SPEEDS     (MSS_MAC_ANEG_10M_FD | MSS_MAC_ANEG_10M_HD | \
                                 MSS_MAC_ANEG_100M_FD | MSS_MAC_ANEG_100M_HD)

/********************************************************************************
  The following definitions are used with function MSS_MAC_get_link_status() to
  report the link’s status.
 */
#define MSS_MAC_LINK_DOWN       0u
#define MSS_MAC_LINK_UP         1u

#define MSS_MAC_HALF_DUPLEX     0u
#define MSS_MAC_FULL_DUPLEX     1u

/*******************************************************************************
  The definition below is provided to create packet buffers in the application
  memory space. It specifies the required size of transmit and receive buffers
  that must be allocated by the application.
 */
#define MSS_MAC_MAX_PACKET_SIZE             1518u

/***************************************************************************//**
  The definition below is provided to specify that the MSS_MAC_init() function
  should attempt to discover the address of the PHY connected to the MAC’s
  management interface. It can be used with mss_mac_cfg_t configuration parameter 
  phy_addr and mss_mac_cfg_t as a parameter to a call to the MSS_MAC_init() function.
 */
#define MSS_MAC_AUTO_DETECT_PHY_ADDRESS     (uint8_t)255u

/***************************************************************************//**
 The mss_mac_transmit_callback_t type defines the prototype for the callback
 function which will be called by the SmartFusion Ethernet MAC driver every 
 time when a packet is sent. The application must first define a function
 of this type and pass it to the SmartFusion Ethernet MAC driver using 
 MSS_MAC_set_tx_callback() function.
 */
typedef void (*mss_mac_transmit_callback_t)(void * caller_info);

/***************************************************************************//**
 The mss_mac_receive_callback_t type defines the prototype for the call-back
 function which will be called by the SmartFusion Ethernet MAC driver every 
 time a packet is received. The application must first define a function
 of this type and pass it to the SmartFusion Ethernet MAC driver using 
 MSS_MAC_set_rx_callback() function.
 */
typedef void (*mss_mac_receive_callback_t)(uint8_t * p_rx_packet,
                                            uint32_t pckt_length,
                                            void * caller_info);

/*******************************************************************************
 * mss mac interface speed
 The mss_mac_speed_t type definition provides various interface speeds supported by
 MAC hardware.
 */
typedef enum
{
    MSS_MAC_10MBPS           = 0x00,
    MSS_MAC_100MBPS          = 0x01,
    MSS_MAC_INVALID_SPEED    = 0x03
} mss_mac_speed_t;

/***************************************************************************//**
 * Statistics counter identifiers are used with MSS_MAC_read_stat routine to
 * receive the count of the requested event occurrences.
 *
 * MSS_MAC_RX_INTERRUPTS
 *      Used to receive the number of receive interrupts occurred.
 *
 * MSS_MAC_RX_FILTERING_FAIL
 *      Used to receive the number of received frames which did not pass the
 *      address recognition process.
 *
 * MSS_MAC_RX_DESCRIPTOR_ERROR
 *      Used to receive the number of occurrences of; no receive buffer was
 *      available when trying to store the received data.
 *
 * MSS_MAC_RX_RUNT_FRAME
 *      Used to receive the number of occurrences of; the frame is damaged by a
 *      collision or by a premature termination before the end of a collision
 *      window.
 *
 * MSS_MAC_RX_NOT_FIRST
 *      Used to receive the number of occurrences of; start of the frame is not
 *      the first descriptor of a frame. of the frame is not the first descriptor
 *      of a frame.
 *
 * MSS_MAC_RX_FRAME_TOO_LONG
 *      Used to receive the number of occurrences of; a current frame is longer
 *      than maximum size of 1,518 bytes, as specified by 802.3.
 *
 * MSS_MAC_RX_COLLISION_SEEN
 *      Used to receive the number of occurrences of; a late collision was seen
 *      (collision after 64 bytes following SFD).
 *
 * MSS_MAC_RX_CRC_ERROR
 *      Used to receive the number of occurrences of; a CRC error has occurred
 *      in the received frame.
 *
 * MSS_MAC_RX_FIFO_OVERFLOW
 *      Used to receive the number of frames not accepted due to the receive FIFO
 *      overflow.
 *
 * MSS_MAC_RX_MISSED_FRAME
 *      Used to receive the number of frames not accepted due to the unavailability
 *      of the receive descriptor.
 *
 * MSS_MAC_TX_INTERRUPTS
 *      Used to receive the number of transmit interrupts occurred.
 *
 * MSS_MAC_TX_LOSS_OF_CARRIER
 *      Used to receive the number of occurrences of; a loss of the carrier during
 *      a transmission.
 *
 * MSS_MAC_TX_NO_CARRIER
 *      Used to receive the number of occurrences of; the carrier was not asserted
 *      by an external transceiver during the transmission.
 *
 * MSS_MAC_TX_LATE_COLLISION
 *      Used to receive the number of occurrences of; a collision was detected
 *      after transmitting 64 bytes.
 *
 * MSS_MAC_TX_EXCESSIVE_COLLISION
 *      Used to receive the number of occurrences of; the transmission was aborted
 *      after 16 retries.
 *
 * MSS_MAC_TX_COLLISION_COUNT
 *      Used to receive the number of collisions occurred.
 *
 * MSS_MAC_TX_UNDERFLOW_ERROR
 *      Used to receive the number of occurrences of; the FIFO was empty during the
 *      frame transmission.
 */
typedef enum
{
    MSS_MAC_RX_INTERRUPTS,
    MSS_MAC_RX_FILTERING_FAIL,
    MSS_MAC_RX_DESCRIPTOR_ERROR,
    MSS_MAC_RX_RUNT_FRAME,
    MSS_MAC_RX_NOT_FIRST,
    MSS_MAC_RX_NOT_LAST,
    MSS_MAC_RX_FRAME_TOO_LONG,
    MSS_MAC_RX_COLLISION_SEEN,
    MSS_MAC_RX_CRC_ERROR,
    MSS_MAC_RX_FIFO_OVERFLOW,
    MSS_MAC_RX_MISSED_FRAME,

    MSS_MAC_TX_INTERRUPTS,
    MSS_MAC_TX_LOSS_OF_CARRIER,
    MSS_MAC_TX_NO_CARRIER,
    MSS_MAC_TX_LATE_COLLISION,
    MSS_MAC_TX_EXCESSIVE_COLLISION,
    MSS_MAC_TX_COLLISION_COUNT,
    MSS_MAC_TX_UNDERFLOW_ERROR
} mss_mac_stat_t;

/*******************************************************************************
  SmartFusion Ethernet MAC Configuration Structure.
  The mss_mac_cfg_t type provides the prototype for the configuration values of the
  SmartFusion Ethernet MAC. You need to create a record of this type to hold the
  configuration of the MAC. The MSS_MAC_cfg_struct_def_init() function can be used to
  initialize the configuration record to default values. Later, the configuration
  elements in the record can be changed to desired values.

  The values of the store_and_forward, threshold_control and tx_threshold_mode
  together affect the transmit FIFO threshold level.
  The table below lists the transmit FIFO threshold levels. These levels are
  specified in bytes.

  store_and_forward   threshold_control   tx_threshold_mode  tx_threshold_mode
                                             = 100Mb            = 10Mb

        0                   00                  64                  128
        0                   01                  128                 256
        0                   10                  128                 512
        0                   11                  256                 1024
        1                   xx             Store and forward  Store and forward
        
  link_speed:
    The linkspeed configuration parameter specifies the allowed link speeds. It
    is a bit-mask of the various link speed and duplex modes. The
    MSS_MAC_cfg_struct_def_init() function sets this configuration parameter to
    MSS_MAC_ANEG_ALL_SPEEDS indicating that a link will be setup for any available
    speed and duplex combination. The linkspeed configuration can be set to a
    bitmask of the following defines to specify the allowed link speed and
    duplex mode:
        - MSS_MAC_ANEG_10M_FD
        - MSS_MAC_ANEG_10M_HD
        - MSS_MAC_ANEG_100M_FD
        - MSS_MAC_ANEG_100M_HD
  
  loopback:
    The loopback configuration parameter specifies if transmit packets should be
    looped back to the Ethernet MAC by the PHY. Set this configuration parameter
    to MSS_MAC_ENABLE if you want transmitted packets to be looped back to the
    receive side of the Ethernet MAC. The MSS_MAC_cfg_struct_def_init() function
    sets this configuration parameter to MSS_MAC_DISABLE for normal operations.
    
  receive_all:
    When Enabled, all incoming frames are received, regardless of their destination
    address. An address check is performed, and the result of the check is written
    into the receive descriptor.
  
  store_and_forward:
    When enabled, the transmission starts after a full packet is written into the
    transmit FIFO, regardless of the current FIFO threshold level.
  
  pass_all_multicast:
    When Enabled, all frames with multicast destination addresses will be received,
    regardless of the address check result.

  promiscous_mode:
    When enabled, all frames will be received regardless of the address check result.
    An address check is not performed.

  pass_badframe:
    When set, SmartFusion Ethernet MAC transfers all frames into the data buffers, 
    regardless of the receive errors. This allows the runt frames, 
    collided fragments, and truncated frames to be received.

  mac_addr:
    The mac_addr configuration parameter is a 6-byte array containing the
    local MAC address of the Ethernet MAC.

  phy_address:
    The phy_address parameter specifies the address of the PHY device, set in
    hardware by the address pins of the PHY device.    
 */
typedef struct
{
    uint8_t     link_speed;              /*Link speed: 10Mbps, 100Mbps, auto-negotiate*/
    uint8_t     loopback;                /*Enable Tx packets loopback*/
    uint8_t     receive_all;             /*Enable/Disable value, default is disable*/
    uint8_t     tx_threshold_mode;       /*Transmit Threshold mode, default is 10Mbps mode*/
    uint8_t     store_and_forward;       /*Enable/Disable value, default is disable*/
    uint8_t     threshold_control;       /*Threshold control, default is 00*/
    uint8_t     pass_all_multicast;      /*Enable Disable Value, default is Disabled*/
    uint8_t     promiscous_mode;         /*Enable Disable Value, default is Enabled*/
    uint8_t     pass_badframe;           /*Enable Disable Value, default Disabled*/
    uint8_t     mac_addr[6];             /*MAC address of the driver instance*/
    uint8_t     phy_addr;                /*Address of the PHY device*/
} mss_mac_cfg_t;

/***************************************************************************//**
 * Descriptor structure
 */
typedef struct
{
    uint32_t        descriptor_0;
    uint32_t        descriptor_1;
    const uint8_t * buffer_1;
    uint32_t        buffer_2;
    void *          caller_info;
} mss_mac_tx_descriptor_t;

typedef struct
{
    uint32_t   descriptor_0;
    uint32_t   descriptor_1;
    uint8_t *  buffer_1;
    uint32_t   buffer_2;
    void *     caller_info;
} mss_mac_rx_descriptor_t;

/*******************************************************************************
 * Transmit and Receive statistics.
 * Statistic of below type, which is desired to be read is to be passed to the
 * function MSS_MAC_read_stat().
 */
typedef struct
{
    uint32_t rx_interrupts;            /**< Number of receive interrupts occurred.*/
    uint32_t rx_filtering_fail;        /**< Number of received frames which did not pass
                                        the address recognition process.*/
    uint32_t rx_descriptor_error;    /**< Number of occurrences of; no receive buffer was
                                        available when trying to store the received data.*/
    uint32_t rx_runt_frame;            /**< Number of occurrences of; the frame is damaged by
                                        a collision or by a premature termination before
                                        the end of a collision window.*/
    uint32_t rx_not_first;            /**< Number of occurrences of; start of the frame is
                                        not the first descriptor of a frame.*/
    uint32_t rx_not_last;            /**< Number of occurrences of; end of the frame is not
                                        the first descriptor of a frame.*/
    uint32_t rx_frame_too_long;        /**< Number of occurrences of; a current frame is
                                        longer than maximum size of 1,518 bytes, as specified
                                        by 802.3.*/
    uint32_t rx_collision_seen;        /**< Number of occurrences of; a late collision was seen
                                        (collision after 64 bytes following SFD).*/
    uint32_t rx_crc_error;            /**< Number of occurrences of; a CRC error has occurred
                                        in the received frame.*/
    uint32_t rx_fifo_overflow;        /**< Number of frames not accepted due to the receive
                                        FIFO overflow.*/
    uint32_t rx_missed_frame;        /**< Number of frames not accepted due to the
                                        unavailability of the receive descriptor.*/

    uint32_t tx_interrupts;            /**< Number of transmit interrupts occurred.*/
    uint32_t tx_loss_of_carrier;    /**< Number of occurrences of; a loss of the carrier
                                        during a transmission.*/
    uint32_t tx_no_carrier;            /**< Number of occurrences of; the carrier was not asserted
                                        by an external transceiver during the transmission.*/
    uint32_t tx_late_collision;        /**< Number of occurrences of; a collision was detected
                                        after transmitting 64 bytes.*/
    uint32_t tx_excessive_collision;/**< Number of occurrences of; the transmission was
                                        aborted after 16 retries.*/
    uint32_t tx_collision_count;    /**< Number of collisions occurred.*/
    uint32_t tx_underflow_error;    /**< Number of occurrences of; the FIFO was empty during
                                        the frame transmission.*/
} mss_mac_statistics_t;

/***************************************************************************//**
 mss_mac_instance_t
  The mss_mac_instance_t structure is used to record SmartFusion Ethernet MAC instance.

  tx_descriptors:
    The tx_descriptors parameter is the array of transmit packet descriptors.

  rx_descriptors:
    The rx_descriptors parameter is the array of receive packet descriptors.

  tx_complete_handler:
    The tx_complete_handler parameter holds the call-back function provided by
    user using the MSS_MAC_set_tx_callback() function for this instance of the
    MAC hardware instance. This call-back function will be called by
    this driver on completion of every packet transmit operation.

  pckt_rx_callback:
    The pckt_rx_callback parameter holds the call-back function provided by user
    using the MSS_MAC_set_rx_callback() function for this instance of the
    MAC hardware instance. This call-back function will be called by
    this driver on reception of a packet.

  first_tx_index:
    The first_tx_index parameter is the index of the first transmit descriptor
    in a sequence of transmit frames.
  
  last_tx_index:
    The last_tx_index parameter is the index of the last transmit descriptor in
    a sequence of transmit frames.
  
  next_free_tx_index:
    The next_free_tx_index parameter is the index of the next available transmit
    descriptor.
  
  next_free_rx_desc_index:
    The next_free_rx_desc_index parameter is the index of the next available
    receive descriptor.
  
  first_rx_desc_index:
    The first_rx_desc_index parameter is the index of the first receive
    descriptor in a sequence of received frames.

  statistics:
    The statistics parameter is used to keep track of the transmit operation, the
    receive operation and the health of the MAC hardware instance.
    This parameter is used by this driver to return the statistics values to the
    user.

  previous_speed:
    The previous_speed parameter is used to detect changes in link speed. It is
    use to detect a change in link speed between calls to function
    MSS_MAC_get_link_status() and update the MAC hardware accordingly.
    
  previous_duplex_mode:
    The previous_duplex_mode parameter is used to detect changes in link duplex
    mode. It is use to detect a change in duplex mode between calls to function
    MSS_MAC_get_link_status() and update the MAC hardware accordingly.

  phy_address:
    The phy_address parameter specifies the address of the PHY device, set in
    hardware by the address pins of the PHY device. The phy_address parameter can
    be a value from 0 to 31.

  local_mac_addr:
    The local_mac_addr parameter is a 6-byte array containing the
    local MAC address of the Ethernet MAC.
*/
typedef struct
{    
    mss_mac_tx_descriptor_t tx_descriptors[MSS_MAC_TX_RING_SIZE];/* Transmit descriptor table */
    mss_mac_rx_descriptor_t rx_descriptors[MSS_MAC_RX_RING_SIZE];/* Receive descriptor table */
    mss_mac_transmit_callback_t     tx_complete_handler;
    mss_mac_receive_callback_t      pckt_rx_callback;
    int16_t    first_tx_index;
    int16_t    last_tx_index;
    int16_t    next_free_tx_index;
    int16_t    next_free_rx_desc_index;
    int16_t    first_rx_desc_index;
    mss_mac_statistics_t statistics;
    mss_mac_speed_t previous_speed;
    uint8_t     previous_duplex_mode;
    uint8_t phy_address;      /*MII address of the connected PHY*/      
    uint8_t local_mac_addr[6];
} mss_mac_instance_t;

/***************************************************************************//**
 * 
 */

/******************************* FUNCTIONS ************************************/

/***************************************************************************//**
  @brief MSS_MAC_cfg_struct_def_init()
  The MSS_MAC_cfg_struct_def_init() function initializes a mss_mac_cfg_t configuration
  data structure to default values. This default configuration can then be used
  as parameter to MSS_MAC_init(). Typically the default configuration would be
  modified to suit the application before being passed to MSS_MAC_init(). At a
  minimum you need to set the local MAC address.

  @param cfg
  The cfg parameter is a pointer to a data structure of type mss_mac_cfg_t containing
  the requested configuration for the MAC hardware instance.
  This data structure must first be initialized by calling the
  MSS_MAC_cfg_struct_def_init() function to fill the configuration data structure
  with default values. You can then overwrite some of the default settings
  with the ones specific in the application before passing this data structure
  as parameter to the call to the MSS_MAC_init() function. At a minimum the
  mac_addr[6] array of the configuration data structure must be over written to
  contain a unique value used as the device’s MAC address.

  @return
  This function does not return a value.

  Example:
  The example below demonstrates the use of the MSS_MAC_cfg_struct_def_init()
  function. It retrieves the default MAC configuration and modifies it to
  phy address 0x01. This example also demonstrates how to assign the device's 
  MAC address and a 100Mbps full duplex link.
  @code
    mss_mac_cfg_t mac_config;
    
    MSS_MAC_cfg_struct_def_init(&mac_config);
    
    mac_config.phy_addr = 0x01;
    mac_config.link_speed = MSS_MAC_ANEG_100M_FD;
    mac_config.mac_addr[0] = 0xC0u;
    mac_config.mac_addr[1] = 0xB1u;
    mac_config.mac_addr[2] = 0x3Cu;
    mac_config.mac_addr[3] = 0x88u;
    mac_config.mac_addr[4] = 0x88u;
    mac_config.mac_addr[5] = 0x88u;
    
    MSS_MAC_init(&mac_config);
  @endcode
 */
void
MSS_MAC_cfg_struct_def_init
(
    mss_mac_cfg_t * cfg
);

/***************************************************************************//**
  @brief MSS_MAC_init
  The MSS_MAC_init() function initializes the Ethernet MAC hardware and the
  driver internal data structures. The MSS_MAC_init() function takes a pointer to a
  configuration data structure of type mss_mac_cfg_t as parameter. This
  configuration data structure contains all the information required to
  configure the Ethernet MAC. The MSS_MAC_init() function initializes the
  descriptor rings and their pointers to initial values. The configuration
  passed to the MSS_MAC_init() function specifies the allowed link speed and duplex
  mode. It is at this point that the application chooses the link speed and
  duplex mode to be advertised during auto-negotiation process.

  @param cfg
  The cfg parameter is a pointer to a data structure of type mss_mac_cfg_t
  containing Ethernet MAC’s requested configuration. This data structure must 
  first be initialized by calling the MSS_MAC_cfg_struct_def_init() function to 
  fill the configuration data structure with default values. You can then 
  overwrite some of the default settings with the ones specific to the application
  before passing this data structure as parameter to the MSS_MAC_init() function.
  At a minimum the mac_addr[6] array of the configuration data structure must be
  overwritten to contain a unique value used as the device’s MAC address.
  The phy_address specifies the address of the PHY device set in
  hardware by the address pins of the PHY device. The phy_address can
  be a value from 0 to 31. This address is board specific and usually depends on
  how PHY configuration pins are connected. You will need to look at the target
  board schematics and PHY datasheet to find the value for this.
  Alternatively, you can use MSS_MAC_AUTO_DETECT_PHY_ADDRESS as value to this
  to request the driver to discover the address of the PHY.

  @return
  This function does not return a value.
  
  Example:
  This example demonstrates the use of the MSS_MAC_init() function to configure the
  Ethernet MAC with the default configuration. Please note a unique MAC
  address must always be assigned through the configuration data passed as
  parameter to the MSS_MAC_init() function.
  
  @code
    mss_mac_cfg_t cfg;

    MSS_MAC_cfg_struct_def_init(&cfg);
    
    cfg.mac_addr[0] = 0xC0u;
    cfg.mac_addr[1] = 0xB1u;
    cfg.mac_addr[2] = 0x3Cu;
    cfg.mac_addr[3] = 0x88u;
    cfg.mac_addr[4] = 0x88u;
    cfg.mac_addr[5] = 0x88u;

    MSS_MAC_init(&cfg);
  @endcode
*/
void
MSS_MAC_init
(
    mss_mac_cfg_t * cfg
);

/***************************************************************************//**
  @brief MSS_MAC_send_pkt
  The MSS_MAC_send_pkt()function initiates the transmission of a packet. It places
  the buffer containing the packet to be sent into one of the Ethernet MAC’s
  transmit descriptors. This function is non-blocking. It will return
  immediately without waiting for the packet to be sent. The Ethernet MAC
  driver indicates that the packet is sent by calling the transmit completion
  handler registered by a call to MSS_MAC_set_tx_callback().

  @param tx_buffer
  The tx_buffer parameter is a pointer to the buffer containing the packet to be
  transmitted.

  @param tx_length
  The tx_length parameter specifies the length in bytes of the packet to be
  transmitted.

  @param p_user_data
  The p_user_data parameter is a pointer to an optional application defined data
  structure. Its usage is left to the application. It is intended to help the
  application manage memory allocated to store packets. The Ethernet MAC
  driver does not make use of this pointer. The Ethernet MAC driver will
  pass back this pointer to the application as part of the call to the transmit
  completion handler registered by the application.

  @return
  This function returns MSS_MAC_SUCCESS on successfully assigning the packet to a
  transmit descriptor. It returns MSS_MAC_FAILED otherwise.

  Example:
  This example demonstrates the use of the MSS_MAC_send_pkt() function. The
  application registers the tx_complete_handler() transmit completion callback
  function with the Ethernet MAC driver by a call to MSS_MAC_set_tx_callback().
  The application dynamically allocates memory for an application defined
  packet_t data structure, builds a packet and calls send_packet(). The
  send_packet() function extracts the pointer to the buffer containing the data
  to transmit and its length from the tx_packet data structure and passes these
  to MSS_MAC_send_pkt(). It also passes the pointer to tx_packet as the p_user_data
  parameter. The Ethernet MAC driver call tx_complete_handler() once the
  packet is sent. The tx_complete_callback() function uses the p_user_data,
  which points to tx_packet, to release memory allocated by the application to
  stored the transmit packet.

  @code
    
    void init(void)
    {
        MSS_MAC_set_tx_callback(tx_complete_handler);
    }
    
    void tx_complete_handler(void * p_user_data)
    {
        release_packet_memory(p_user_data);
    }
    
    void send_packet(app_packet_t * packet)
    {
        MSS_MAC_send_pkt(packet->buffer, packet->length, packet);
    }
    
  @endcode
  @endcode
*/

uint8_t
MSS_MAC_send_pkt
(
    uint8_t const * tx_buffer,
    uint32_t tx_length,
    void * p_user_data
);

/***************************************************************************//**
  @brief MSS_MAC_receive_pkt
  The MSS_MAC_receive_pkt() function assigns a buffer to one of  the Ethernet MAC's
  receive descriptors. The receive buffer specified as parameter will be
  used to receive one single packet. The receive buffer will be handed back to
  the application via a call to the receive callback function assigned through a
  call to MSS_MAC_set_rx_callback(). The MSS_MAC_receive_pkt() function will
  need to be called again pointing to the same buffer if more packets are to be
  received into this same buffer after the packet has been processed by the
  application.
  The MSS_MAC_receive_pkt() function is non-blocking. It will return immediately
  and does not wait for a packet to be received. The application needs to
  implement a receive callback function to be notified that a packet has been
  received.
  The p_user_data parameter can be optionally used to point to a memory
  management data structure managed by the application.

  @param rx_pkt_buffer
  This rx_pkt_buffer parameter is a pointer to a memory buffer. It points to
  the memory that will be assigned to one of the Ethernet MAC's receive
  descriptors. It must point to a buffer large enough to contain the largest
  possible packet.

  @param p_user_data
  The p_user_data parameter is intended to help the application manage memory.
  Its usage is left to the application. The Ethernet MAC driver does not make
  use of this pointer. The  Ethernet MAC' driver will pass this pointer back
  to the application as part of the call to the application’s receive callback
  function to help the application associate the received packet with the memory
  it allocated prior to the call to MSS_MAC_receive_pkt().

  @return
  This function returns MSS_MAC_SUCCESS on successfully assigning the buffer to a
  receive descriptor. It returns MSS_MAC_FAILED otherwise.

  Example:
  The example below demonstrates the use of the MSS_MAC_receive_pkt() function to
  handle packet reception. The init() function calls
  the MSS_MAC_set_rx_callback() function to register the rx_callback() receive
  callback function with the Ethernet MAC driver. The MSS_MAC_receive_pkt()
  function is then called to assign rx_buffer_1 to Ethernet MAC descriptors
  for packet reception. The rx_callback function will be called by the
  Ethernet MAC driver once a packet has been received into one of the
  receive buffers. The rx_callback() function calls the process_rx_packet()
  application function to process the received packet then calls MSS_MAC_receive_pkt()
  to reallocate the receive buffer to receive another packet. The rx_callback()
  function will be called again every time a packet is received to process the
  received packet and reallocate rx_buffer for packet reception.

  Please note the use of the p_user_data parameter to handle the buffer
  reassignment to the Ethernet MAC as part of the rx_callback() function.
  This is a simplistic use of p_user_data. It is more likely that p_user_data
  would be useful to keep track of a pointer to a TCP/IP stack packet container
  data structure dynamically allocated. In this more complex use case, the first
  parameter of MSS_MAC_receive_pkt() would point to the actual receive buffer and
  the second parameter would point to a data structure used to free the receive
  buffer memory once the packet has been consumed by the TCP/IP stack.

   @code
    uint8_t rx_buffer_1[MAC_MAX_PACKET_SIZE];

    void rx_callback
    (
        uint8_t * p_rx_packet,
        uint32_t pckt_length,
        void * p_user_data
    )
    {
        process_rx_packet(p_rx_packet, pckt_length);
        MSS_MAC_receive_pkt((uint8_t *)p_user_data, p_user_data);
    }

    void init(void)
    {
        MSS_MAC_set_rx_callback(rx_callback);
        MSS_MAC_receive_pkt(rx_buffer_1, (void *)rx_buffer_1);
    }
   @endcode
*/
uint8_t
MSS_MAC_receive_pkt
(
    uint8_t * rx_buffer,
    void * p_user_data
);

/***************************************************************************//**
  @brief MSS_MAC_get_link_status()
  The MSS_MAC_get_link_status () function retrieves the status of the link from the
  Ethernet PHY. It returns the current state of the Ethernet link. The speed and
  duplex mode of the link is also returned via the two pointers passed as
  parameter if the link is up. Calling this function also has the side effect of
  updating the MAC’s internal configuration in case the link speed or duplex
  mode changed since the last call to this function. It is recommended to call
  this function at regular interval to handle cable disconnection and
  reconnection ensuring that the MAC is configured properly in case of such an
  event taking place.

  @param speed
  The speed parameter is a pointer to variable of type mss_mac_speed_t where the
  current link speed will be stored if the link is up. This variable is not
  updated if the link is down. This parameter can be set to zero if the caller
  does not need to find out the link speed.

  @param fullduplex
  The fullduplex parameter is a pointer to an unsigned character where the
  current link duplex mode will be stored if the link is up. This variable is
  not updated if the link is down.

  @return
  This function returns MSS_MAC_LINK_UP, if the link is up. It returns 
  MSS_MAC_LINK_DOWN if the link is down.

  Example:
  @code
    uint8_t link_up;
    mss_mac_speed_t speed;
    uint8_t full_duplex
    link_up = MSS_MAC_get_link_status(&speed, &full_duplex);
  @endcode
 */
uint8_t
MSS_MAC_get_link_status
(
    mss_mac_speed_t * speed,
    uint8_t * fullduplex
);

/***************************************************************************//**
  @brief MSS_MAC_read_stat()
  The MSS_MAC_read_stat() function reads the transmit and receive statistics collected
  by the Ethernet MAC driver. This function can be used to read one of statistics
  value as defined in the mss_mac_stat_t enumeration.

  @param stat_id
  This parameter of type mss_mac_stat_t identifies the statistic that will be read.

  @return
  This function returns the value of the requested statistic.

  Example:
  @code
    uint32_t tx_pkts_cnt = MSS_MAC_read_stat(MSS_MAC_TX_INTERRUPTS);
  @endcode

*/
uint32_t
MSS_MAC_read_stat
(
    mss_mac_stat_t stat_id
);

/***************************************************************************//**
  @brief MSS_MAC_set_tx_callback()
  The MAC_set_tx_callback() function registers the function that will be
  called by the Ethernet MAC driver when a packet has been sent.

  @param tx_complete_handler
  The tx_complete_handler parameter is a pointer to the function that will be
  called when a packet is sent by the Ethernet MAC.

  @return
    This function does not return a value.

  Example:
  @code

    void tx_complete_callback (void * p_user_data)
    {
        release_packet_memory(p_user_data);
    }

    void init(void)
    {
        MSS_MAC_set_tx_callback(tx_complete_handler);
    }
    
    void send_packet(packet_t * tx_packet)
    {
        MSS_MAC_send_pkt(tx_packet->buffer, tx_packet->length, tx_packet);
    }
  @endcode

 */
void MSS_MAC_set_tx_callback
(
    mss_mac_transmit_callback_t tx_complete_handler
);

/***************************************************************************//**
  @brief MSS_MAC_set_rx_callback()
  The MSS_MAC_set_rx_callback() function registers the function that will be
  called by the Ethernet MAC driver when a packet is received.

  @param rx_callback
  The rx_callback parameter is a pointer to the function that will be called when a
  packet is received by the Ethernet MAC.
  
  @return
    This function does not return a value.
    
  Example:
  @code
    uint8_t rx_buffer[MAC_MAX_PACKET_SIZE];
    
    void rx_callback
    (
        uint8_t * p_rx_packet,
        uint32_t pckt_length,
        void * p_user_data
    )
    {
        process_rx_packet(p_rx_packet, pckt_length);
        MSS_MAC_receive_pkt(rx_buffer, (void *)0);
    }

    void init(void)
    {
        MSS_MAC_set_rx_callback(rx_callback);
        MSS_MAC_receive_pkt(rx_buffer, (void *)0);
    }
  @endcode
 */
void MSS_MAC_set_rx_callback
(
    mss_mac_receive_callback_t rx_callback
);

/***************************************************************************//**
  @brief MSS_MAC_set_address_filter()
    The MAC_set_address_filter() function implements the frame filtering
    functionality of the driver. This function is used to specify the list of
    destination MAC addresses of received frames that will be passed to the MAC.
    This function takes an array of MAC addresses as parameter and generates the
    correct hash table for that list of addresses. 

  @param  mac_addresses
    The mac_addresses parameter is a pointer to the buffer containing the MAC
    addresses that are used to generate the MAC address hash table.

  @param nb_addresses
    The nb_addresses parameter specifies the number of mac addresses being
    passed in the buffer pointed by the mac_addresses buffer pointer. 

    Note: Each MAC address consists of 6 octets and must be placed in the
    buffer starting with the first (most significant) octet of the MAC address.

  @return
    This function does not return a value.

  Example:
  This example demonstrates the use of the MSS_MAC_set_address_filter() function to
  handle frame filtering.

  @code
    mss_mac_cfg_t mac_config;

    uint8_t mac_data[4][6] = {{0x10, 0x10, 0x10, 0x10, 0x10, 0x10},
                      {0x43, 0x40, 0x40, 0x40, 0x40, 0x43},
                      {0xC0, 0xB1, 0x3C, 0x60, 0x60, 0x60},
                      {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};

    MSS_MAC_cfg_struct_def_init(&mac_config);
    mac_config.phy_addr = MSS_MAC_AUTO_DETECT_PHY_ADDRESS;
    mac_config.mac_addr[0] = 0xC0;
    mac_config.mac_addr[1] = 0xB1;
    mac_config.mac_addr[2] = 0x3C;
    mac_config.mac_addr[3] = 0x60;
    mac_config.mac_addr[4] = 0x60;
    mac_config.mac_addr[5] = 0x60;

    MSS_MAC_init(&mac_config);

    MSS_MAC_set_address_filter(mac_data[0], 4);
    
  @endcode
 */
void MSS_MAC_set_address_filter
(
    const uint8_t * mac_addresses,
    uint32_t nb_addresses
);
/***************************************************************************//**
  @brief MSS_MAC_clear_statistics()
    The MSS_MAC_clear_statistics() function clears all the statistics counter
    registers.
    
  @param
    This function does not take any parameters
    
  @return
    This function does not return a value.
 */
void MSS_MAC_clear_statistics
(
    void
);

#ifdef __cplusplus
}
#endif

#endif    /* MSS_ETHERNET_MAC_H_ */
